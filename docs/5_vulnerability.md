# Table of Contents
0. [Introduction](../README.md#introduction)
1. [Setup](./1_setup.md)
2. [Emulation](./2_emulation.md)
3. [Tracing](./3_tracing.md)
4. [Symbolic Execution](./4_symbex.md)
5. [Vulnerability CVE-2022-27646](./5_vulnerability.md#vulnerability-cve-2022-27646)
    1. [Description](./5_vulnerability.md#description)
    2. [Analysis](./5_vulnerability.md#analysis)
    3. [Memory Layout PoV](./5_vulnerability.md#memory-layout-pov)
6. [Exploitation](./6_exploitation.md)
<!--TODO--------------------------------------------------------------------------------------------
- [X] Maybe move to 5_vulnerability.md
- [ ] What is the size of stack buffer `line`?
- [ ] Write text
    - [X] Pre-auth remote code execution vulnerability in NETGEAR R6700v3 routers over the WAN interface
    - [X] The vulnerability resides in binary `/bin/circled`, which occasionally fetches a file named `circleinfo.txt` from remote web servers. When parsed by the binary `circled`, a stack buffer overflow (CVE-2022-27646) can be triggered. Since the download requests from the routers miss certificate validation (CVE-2022-27644), attackers could trick routers to download malicious files (e.g. using DNS or TCP redirection), leading to arbitrary code execution on the routers. Since `circled` runs as root, attackers may gain full privileges on the routers.
    - [ ]SHA1 of `/bin/circled`: ac86472cdeccd01165718b1b759073b9e6b665e9
    - [ ] In case of a crash, the binary restarts (used to defeat ASRL)
    - [ ] Read file `circleinfo.txt` line-by-line (`fgets` - 1024 bytes), parse two strings per line (`sscanf`) and write them to two stack variables (size 256) without size checking -> stack buffer overflow
--------------------------------------------------------------------------------------------------->
# Vulnerability CVE-2022-27646
Before looking into the details of how [Morion](https://github.com/pdamian/morion) might assist
during [exploit generation](./6_exploitation.md), this chapter provides essential **background
information** necessary for comprehending the targeted vulnerability. For a deeper exploration, we
direct the interested reader to the original writeup by the vulnerability discoverers, available at
[Pwn2own Austin 2021: Defeating the NETGEAR R6700v3](https://www.synacktiv.com/en/publications/pwn2own-austin-2021-defeating-the-netgear-r6700v3.html).
## Description
[CVE-2022-27646](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-27646) corresponds to a
pre-authentication **Remote Code Execution (RCE)** vulnerability in NETGEAR R6700v3 routers 
(version 10.04.120_10.0.91) that might be exploited over the WAN interface.

The vulnerability resides in a binary `/bin/circled`, which occasionally fetches a file named
`circleinfo.txt` from a remote web server. During parsing of the downloaded file, a **stack buffer
overflow** might occur, due to some improper handling of buffer sizes. Since the download request
initiated by binary `circled` misses **certificate validation**
(see [CVE-2022-27644](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-27644)), attackers
could trick vulnerable routers to download a malicious file (e.g. using DNS or TCP redirection),
leading to arbitrary code being executed on the router. Since `circled` runs as *root*, attackers
may gain full privileges on the targeted devices.
## Analysis
In the following, we examine some excerpts from the **reverse engineered binary** and discuss its
improper handling of buffer sizes that culminates in the stack buffer overflow we intend to exploit.

Figure 1 shows the de-compiled pseudo C-code that deals with the **reading and parsing** of file
`/tmp/circleinfo.txt` - a copy of the downloaded file as mentioned in the previous section. Using
the *libc* function `fgets`, the file's content is read line-by-line into a stack buffer (here
called `line`) of size 1024 (0x400). Using the *libc* function `sscanf`, each read line is then
split into two strings (space-separated), which are copied to stack buffers `db_checksum` and
`db_checksum_val`, respectively. As long as the string in buffer `db_checksum` is not equal to
"db_checksum" (`strcmp`), we move on to the next line in the file, if any. The buffer `line` may
therefore contain a maximum of 1023 characters (plus a terminating null-byte).
<hr>
<figure>
  <img src="../images/RE_Vuln_02.svg" alt="Reading and parsing file content"/>
  <figcaption>
    Figure 1: Reverse Engineering - Read file contents line-by-line and split each line into two strings.
  </figcaption>
</figure>
<hr>

As can be seen in Figure 2 below, stack buffers `db_checksum` and `db_checksum_val`, however, only
have a size of 256 bytes each. A line e.g. consisting of the string `"A"*1021 + " X"` will therefore
lead to a stack buffer overflow (of buffer `db_checksum` in the listed example string).
<hr>
<figure>
  <img src="../images/RE_Vuln_01.svg" alt="Initializing of stack buffers"/>
  <figcaption>
    Figure 2: Reverse Engineering - Zero-initialization of relevant stack buffers.
  </figcaption>
  </br>
</figure>
<hr>

If we look a bit further down in `circled`'s de-compiled code, and as indicated by Figure 3, the
stack buffer `line` is subsequently reused to store the MD5 sum of the file `/tmp/database.bin`.
This file corresponds to another file being downloaded from the aforementioned web server. Although
an attacker might as well control the contents of `database.bin`, full control over the resulting
MD5 sum might be harder to achieve. In consequence, and as also shown in section [Memory Layout PoV
(./5_vulnerability.md#memory-layout-pov), the first 34 bytes of buffer `line` might not so easily
be controlled by an attacker.
<hr>
<figure>
  <img src="../images/RE_Vuln_03.svg" alt="Reading MD5 sum"/>
  <figcaption>
    Figure 3: Reverse Engineering - Reading MD5 sum from STDIN.
  </figcaption>
</figure>
<hr>

**Note**: The stack buffer `line` is interesting with respect to exploitation, since - and in
contrast to buffers `db_checksum` and `db_checksum_val` - it can include null-bytes (`fgets` reads
all bytes until either `n-1` bytes are read, a newline-character or an end-of-file condition is
encountered).

What registers and memory locations an attacker can influence, and in particular how, is not always
so easy to determine, respectively requires time-consuming reverse engineering and debugging
efforts. As we will see in the next chapter about [Exploitation](./6_exploitation.md), this is where
symbolic execution might help us by simplifying certain tasks, so that we do not have to understand
all subtleties to crafting a working exploit.
## Memory Layout PoV
PoV Payload: `b'A'*1021 + b' X'`

1. `fgets [1024]`: 
2. ``

      char *fgets(char *restrict s, int n, FILE *restrict stream);
       The fgets() function shall read bytes from stream into the array
       pointed to by s until n-1 bytes are read, or a <newline> is read
       and transferred to s, or an end-of-file condition is encountered.
       A null byte shall be written immediately after the last byte read
       into the array.  If the end-of-file condition is encountered
       before any bytes are read, the contents of the array pointed to
       by s shall not be changed.

<hr>
<figure>
  <img src="../images/Memory_Layout-PoV.svg" alt="Memory Layout PoV"/>
  <figcaption>
    Fig. 1: Memory Layout - Showing the stack layout for the proof-of-vulnerability (PoV) payload.
  </figcaption>
</figure>
<hr>

----------------------------------------------------------------------------------------------------
[Back-to-Top](./5_vulnerability.md#table-of-contents)