# Table of Contents
0. [Introduction](../README.md#introduction)
1. [Setup](./1_setup.md)
2. [Emulation](./2_emulation.md)
3. [Tracing](./3_tracing.md)
4. [Symbolic Execution](./4_symbex.md)
5. [Vulnerability CVE-2022-27646](./5_vulnerability.md#vulnerability-cve-2022-27646)
    1. [Description](./5_vulnerability.md#description)
    2. [Analysis](./5_vulnerability.md#analysis)
    3. [Memory Layout](./5_vulnerability.md#memory-layout)
6. [Exploitation](./6_exploitation.md)
# Vulnerability CVE-2022-27646
Before looking into the details of how [Morion](https://github.com/cyber-defence-campus/morion)
might assist during [exploit generation](./6_exploitation.md), this chapter provides essential
**background information** necessary for comprehending the targeted vulnerability. For a deeper
exploration, we direct the interested reader to the original writeup by the vulnerability
discoverers, available at
[Pwn2own Austin 2021: Defeating the NETGEAR R6700v3](https://www.synacktiv.com/en/publications/pwn2own-austin-2021-defeating-the-netgear-r6700v3.html).
## Description
[CVE-2022-27646](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-27646) corresponds to a
pre-authentication **remote code execution (RCE)** vulnerability in NETGEAR R6700v3 routers 
(version 1.0.4.120_10.0.91) that might be exploited over the WAN interface.

The vulnerability resides in a binary `/bin/circled`, which occasionally fetches a file named
`circleinfo.txt` from a remote web server. During parsing of the downloaded file, a **stack buffer
overflow** might occur, due to some improper handling of buffer sizes. Since the download request
initiated by binary `circled` misses **certificate validation**
(see [CVE-2022-27644](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-27644)), attackers
could trick vulnerable routers to download a malicious file (e.g. using DNS or TCP redirection),
leading to arbitrary code being executed on the router. Since `circled` runs as *root*, attackers
may gain full privileges on the targeted devices.
## Analysis
In the following, we examine some excerpts of the **reverse engineered binary** and discuss its
improper handling of buffer sizes that culminate in the stack buffer overflow we intend to exploit.

Figure 5.1 shows the de-compiled pseudo C-code that deals with the **reading and parsing** of file
`/tmp/circleinfo.txt` - a copy of the downloaded file as mentioned in the previous section. Using
the *libc* function `fgets`, the file's content is read line-by-line into a stack buffer (here
called `line`) of size 1024 (0x400). Using the *libc* function `sscanf`, each read line is then
split into two strings (space-separated), which are copied to stack buffers `db_checksum` and
`db_checksum_val`, respectively. As long as the string in buffer `db_checksum` is not equal to
`"db_checksum"` (see *libc* function `strcmp`), we move on to the next line in the file, if there is
any left. The buffer `line` may therefore contain a maximum of 1023 characters (plus a terminating
null-byte).
<hr>
<figure>
  <img src="../images/RE_Vuln_02.svg" alt="Reading and parsing file content"/>
  <figcaption>
    Figure 5.1: Reverse Engineering - Read file contents line-by-line and split each line into two strings.
  </figcaption>
</figure>
<hr>

As can be seen in Figure 5.2 below, stack buffers `db_checksum` and `db_checksum_val`, however, only
have a size of 256 bytes each. A line, e.g. consisting of the string `"A"*1021 + " X"`, will
therefore lead to a **stack buffer overflow** (of buffer `db_checksum` in the listed example) since
the first copied string will have a length of 1021.
<hr>
<figure>
  <img src="../images/RE_Vuln_01.svg" alt="Initializing of stack buffers"/>
  <figcaption>
    Figure 5.2: Reverse Engineering - Zero-initialization of relevant stack buffers.
  </figcaption>
  </br>
</figure>
<hr>

If we look a bit further down in `circled`'s de-compiled code, and as indicated by Figure 5.3, the
stack buffer `line` is subsequently **reused** to store the MD5 sum of the file `/tmp/database.bin`.
This file corresponds to another file being downloaded from the aforementioned web server. Although
an attacker might as well control the contents of `database.bin`, full control over the resulting
MD5 sum might be harder to achieve. In consequence, and as also shown in section
[Memory Layout](./5_vulnerability.md#memory-layout) below, the first 34 bytes (32 bytes for the MD5
sum, plus terminating bytes `\x0a\x00`) of buffer `line` might not so easily be controlled by an
attacker.
<hr>
<figure>
  <img src="../images/RE_Vuln_03.svg" alt="Reading MD5 sum"/>
  <figcaption>
    Figure 5.3: Reverse Engineering - Read a MD5 sum from STDIN.
  </figcaption>
</figure>
<hr>

**Note**: The stack buffer `line` is interesting with respect to exploitation, since - and in
contrast to buffers `db_checksum` and `db_checksum_val` - it can contain **null-bytes** (`fgets`
reads all bytes until either `n-1` bytes are read, a newline-character or an end-of-file condition
is encountered).

What registers and memory locations an attacker can influence, and in particular how, is not always
so easy to determine, and typically requires time-consuming reverse engineering and debugging
efforts. As we will see in the next chapter about [Exploitation](./6_exploitation.md), this is where
[Morion](https://github.com/cyber-defence-campus/morion), respectively **symbolic execution**, might
help by simplifying certain tasks, so that we do not have to understand all subtleties in full
detail (e.g. which bytes we control, are byte values restricted, etc.) to craft a working exploit.
## Memory Layout
Figure 5.4 below gives an overview of the **memory layout** that results when the file
`circleinfo.txt` contains the content `b'A'*1021 + b' X'` (note that this is exactly the file
content we used for [trace collection](./3_tracing.md#run), as returned by
[circled.server.py](../server/circled.server.py#L46)). We refer to this content as a
**proof-of-vulnerability (PoV)** payload, since it crashes the binary `circled`, or to be
more specific, leads to the program counter (PC) being overwritten by some attacker-controllable
values (see also chapter [Exploitation](./6_exploitation.md)). Such PoV payloads might for instance
be the output of a fuzzing campaign. The memory layout shown in Figure 5.4 depicts the situation
after executing the code discussed in section [Analysis](./5_vulnerability.md#analysis). Note also
that the memory addresses shown in Figure 5.4 might be different in case you execute the target
binary yourself.

<hr>
<figure>
  <img src="../images/Memory_Layout-PoV.svg" alt="Memory Layout PoV"/>
  <figcaption>
    Figure 5.4: Memory Layout - Showing relevant parts of the stack when using the proof-of-vulnerability (PoV) payload.
  </figcaption>
</figure>
<hr>

After getting a basic understanding of vulnerability
[CVE-2022-27646](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-27646), it is finally time
for the fun part - the actual **exploitation**! The [next chapter](./6_exploitation.md) tries to
demonstrate that, at least for simple vulnerabilities like the one explained here, and with the help
of a tool like [Morion](https://github.com/cyber-defence-campus/morion), not even this level of
vulnerability understanding might be necessary to craft a working exploit.

----------------------------------------------------------------------------------------------------
[Back-to-Top](./5_vulnerability.md#table-of-contents)